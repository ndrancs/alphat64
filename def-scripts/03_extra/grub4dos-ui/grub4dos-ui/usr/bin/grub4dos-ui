#!/usr/bin/bash
###########################################################################
# 
# Grub4DOS UI - Fork of grub4dosconfig
# Copyright (c) alphaOS
#
# grub4dosconfig
# 12aug11 by Masaki Shinomiya <shino@pos.to>
#
###########################################################################
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###########################################################################

MYVERSION=1.0.0
APPNAME=$(basename "$0")
ALPHAOS_DIRNAMES="alphaos alpha alphaos.usb alphaos-usb alphaos_live backup"
APPTMP=/tmp/$APPNAME
mkdir -p $APPTMP
MYLOG=$APPTMP/$APPNAME.log
echo "$0 $@" > $MYLOG
echo "version $MYVERSION" >>  $MYLOG
date  >>  $MYLOG
CREDIT="$APPNAME $MYVERSION"
DEBUGFLAG=""
case $1 in
*-d*) DEBUGFLAG="yes"; shift;;
*-*) echo $CREDIT; exit;;
esac
debug() {
  [ "$DEBUGFLAG" != "yes" ] && return
  echo "$@" >&2
  echo "$@" >> $MYLOG
} 

PUPPYOPTIONS="pfix=fsck"
LINUXOPTIONS="ro"
SAFEOPTIONS="pfix=ram,nox acpi=off apm=off nosmp noapic nodma nopcmcia"
SPLASHPATH=""

export TEXTDOMAIN=grub4dos-ui
export TEXTDOMAINDIR=/usr/share/locale
export OUTPUT_CHARSET=UTF-8
_WebPage="http://diddy.boot-land.net/grub4dos/Grub4dos.htm"
_Title=$(echo "Grub4DOS UI")
_Welcome1=$(echo "Configure bootup loader(Grub4Dos).")
_Welcome2=$(echo "Click 'OK' to search installed systems.")
_Where=$(echo "Where to install bootup loader(Grub4Dos)?")
_Where2=$(echo "Usually on the MBR of the 1st drive")
_SearchOnlyD=$(echo "Search within only this device")
_Keep=$(echo "Do not rewrite the existing boot record")
_KeepMenu=$(echo "Do not rewrite 'menu.lst'")
_unlessFloppy=$(echo "(Tick options ignored as for floppy)")
_More_info=$(echo "Grub4Dos Guide")
_Notask=$(echo "You chose nothig to do.")
_Probing=$(echo "Searching. Please wait...")
_Quit=$(echo "Press 'OK' to quit this program.")
_List=$(echo "List of detected operating systems")
_List2=$(echo "You can rewrite each label. Or, erase. Caution: You cannot change their order.")
_Frugal=$(echo "Frugal installed Puppy Linux")
_Full=$(echo "AlphaOS frugal or other Linux full install")
_Win=$(echo "Windows")
_Chain_frame=$(echo 'Bootable partitions')
_Comfirm=$(echo "Comfirmation")
_Comfirm1=$(echo "The boot loader(Grub4Dos) will be installed on")
_Comfirm3=$(echo "Press 'OK' to install. Press 'Cancel' if you do not like to.")
_Floppy=$(echo "Insert floppy disk (all the data will be eraesed).")
_Formating=$(echo "Formating floppy. Please wait ...")
_Writing=$(echo "Installing Grub4Dos. Please wait...")
_Error=$(echo "Somewhat error occured.")
_Success=$(echo "Grub4Dos successfully installed.")
_Fairwell1=$(echo "The file(s),")
_Fairwell2=$(echo "is on")
_Fairwell3=$(echo "You can edit 'menu.lst' before reboot.")
_Unmount=$(echo "If you installed on a removable device, ensure unmount the drive before remove it.")
_Saved=$(echo "Old 'menu.lst' found and renamed as follows:")
_NoBR=$(echo "Note: the boot record is not changed.")
_NoMBR=$(echo "The MBR of the 1st drive has not changed this time. You may need to configure the BIOS or the MBR to make chain to")
_NoBootFlag=$(echo "The boot-flag of the partition %s is not set. You may need to set the boot-flag using Gparted.")
_NoBootMBR=$(echo "The MBR of the drive %s seems not bootable. You may need to install some bootloader there.")
_Edit=$(echo "Edit 'menu.lst'")
_Edit_Advanced=$(echo "Edit 'Advanced menu'")
_no_grub=$(echo "Grub not found. Grub(other than Grub4Dos) which supports ext4 is required if the 1st partition of the target drive is ext4 file system.")
_online=$(echo 'Grub4dos Guide online')
_Puppy_opt=$(echo "Options")
_Puppy_opt_tip=$(echo "You can edit the boot options add to all frugal installed Puppy.")
_Linux_opt=$(echo "Options")
_Linux_opt_tip=$(echo "You can edit the boot options add to all full installed Linux.")
_MBR_saved=$(echo "Old MBR is saved")
_Restore_MBR=$(echo "To restore the MBR, type next command on console")
_Duplicated_W=$(echo "Next puppy directories have same name on multiple partitions. It may confuse the bootup procces. Recommended to press 'Cancel' to quit this program, change the names of the directories, and then restart this program.\\nBut you can continue this program pressing 'OK'.")
_Win3=$(echo "The first entry is always shown regardless Windows are installed or not. Recommended to keep the entry.")
_Missing=$(echo "The Grub4DOS UI seems improperly installed. Missing files")
_Lacking=$(echo "Some componets are lacking to perform this function")
_NoSupport=$(echo 'No supported filesystems found in')
_SPT_Err1=$(echo 'Sectors/Track is expected 63.')
_SPT_Drive=$(echo 'But the drive')
_SPT_Sector=$(echo 'seems Sectors/Track')
_SPT_Err2=$(echo 'The Grub4DOS UI does not support this drive.')
_SPT_Err3=$(echo 'Remove all the partitions on the drive (after backing up all the data) and rewrite the partition tabe with Gparted.')
_Where_tip=$(echo 'Select the device you would like to boot from. Usually the first drive(MBR), but you can select floppy(fd0) if available, or USB removable devices. You may need to change the BIOS setting.')
_Ignored=$(echo "Ignored for floppies")
_Forced=$(echo 'Or, for PBS install, it searches only the partiton and is recommended.')
_SearchOnly_tip=$(echo 'Limit the search scope so that the installations on other drives are not listed up. Recommended only for removal devices.')
_Keep_tip="$(echo 'Only if you do not want to change your existing MBR. Your boot sequence should be ready to start up grubldr.') $_Ignored"
_KeepMenu_tip="$(echo 'Only if you want to keep the existing 'menu.lst' and you can handle it manually.') $_Ignored"
_LegacyMenu=$(echo "Legacy compatible 'menu.lst'")
_LegacyMenu_tip=$(echo "Only if you still use legacy grub. You also need to tick on 'Do not rewrite the existing boot record'. The 'menu.lst' is made with legacy grub compatible commands.")
_Anothermenu_W=$(echo "A 'menu.lst' found at irregular place")
_Nomenu_new=$(echo "Recommended is to make new one")
_Nomenu_cont=$(echo "but you can skip to make new one by checking the box on.")
_Nomenu_W=$(echo "No 'menu.lst' found.")
_Not_found=$(echo 'Not found')
_Show_partition=$(echo 'Show PBS')
_Hide_partition=$(echo 'Hide PBS')
_Show_partition_tip=$(echo 'Show all partitions if you want to install the bootloader on the partition boot sector(PBS).')
_Single_page_menu=$(echo 'Single page menu')
_Single_page_menu_tip=$(echo 'Single page menu with advanced entries. Or, the advanced menu at next page')
_Device=$(echo "Device")
_Information=$(echo "Information")
for lng in C $(echo $LANGUAGE|cut -d':' -f1) $LC_ALL $LANG;do :;done
lng1=$(echo $lng|cut -d'.' -f1)
lng2=$(echo $lng|cut -d'_' -f1)

splash() {
  ACTION="$1"
  MSG="$2"
  if [ "$ACTION" = "start" ]
  then
  	DIALOG="<window title=\"$_Title\" icon-name=\"grub4dos-ui\" resizable=\"false\"><hbox>
  	  <pixmap><input file icon=\"system-run\"></input></pixmap>
  	  <text><input>echo -en \"$MSG\"</input></text>
</hbox></window>"
  	$GTKDIALOG -p DIALOG  -c &>/dev/null &
  	XPID=$!
  	return
  fi
  [ "$XPID" = "" ] && return
  kill $XPID &>/dev/null
  XPID=""
  return
}
probing() {
  splash "$1" "$_Probing"
}
umountmine() {
	[ "$SMOUNTED" != "" ] && mount |grep -q " $SMOUNTED " && umount $SMOUNTED && SMOUNTED=""
}

mountpoint() {
  PART=$(echo $1|cut -d '|' -f 1|cut -d '/' -f 3)
  FS=$(echo $1|cut -d '|' -f 2)
  umountmine
  MP=$(mount | grep "^/dev/$PART[ ]" | head -n 1 | cut -d ' ' -f 3)
  if [ "$MP" = "" ]; then
	MP="/mnt/$PART"
	mount | grep -q " $MP " &&  umount "$MP"
	[ -d "$MP" ] || mkdir -p "$MP"
	OPT=""
	[ "$FS" = "vfat" ] && OPT='-o iocharset=utf8'
	mount -t $FS $OPT /dev/$PART "$MP" >>  $MYLOG 2>&1 && SMOUNTED="$MP" || MP=""
	[ "$MP" = "" ] && return 1
  fi
  return 0
}

read_distro_specs() {
  distro_specs "$@" | trim | tr ' ' '_' 
}
distro_specs() {
  TOPDIR=$1
  DISTRO_NAME=""
  DISTRO_VERSION=""
  [ "$KEYFILE" = "" ] && echo "Unknown" && return
  KFILE=$(echo "$KEYFILE" | cut -d',' -f1)
  KBASE=$(basename "$KFILE")
  SUBDIR=$(basename "$(dirname "/$KFILE")")
  [ "$SUBDIR" = "/" ] && SUBDIR=""
  case $KBASE in
  bootmgr)  DISTRO_NAME="Windows Vista and recent" ;;
  ntldr) DISTRO_NAME="Windows NT/2000/2003/Xp"
    [ -f $TOPDIR/boot.ini ] && DISTRO_NAME=$(grep 'WINDOWS=' $TOPDIR/boot.ini| head -n 1| cut -d'=' -f2| cut -d'/' -f1|  tr -d '"' | trim)
    [ "$DISTRO_NAME" = "" ] && DISTRO_NAME="Windows NT/2000/2003/Xp"
    ;;
  io.sys) DISTRO_NAME="Windows 9x/Me";;
  plpbt.bin) DISTRO_NAME="PLOP_boot_manager";;
  rootfs*.gz) DISTRO_NAME="Slitaz Linux";;
  initrfs.img) DISTRO_NAME="alphaOS";;
  initrd) DISTRO_NAME="Fatdog64";;
  puppy.sfs)
    DISTRO_IDSTRING=$(tail -c 16 $TOPDIR$KEYFILE)
    DISTRO_VERSION=$(echo $DISTRO_IDSTRING| cut -b1-6| tr -dc 'a-z0-9')
    MAJOR=$(echo $DISTRO_VERSION | cut -b1-4)
    MINOR=$(echo $DISTRO_VERSION | cut -b5-6| tr -dc '0-9')
    [ "$MINOR" = "" ] && MINOR=0
    [ $MINOR -eq 0 ] && DISTRO_VERSION=$MAJOR || DISTRO_VERSION=$MAJOR-$MINOR
    [ "$DISTRO_VERSION" != "" ] || DISTRO_VERSION=$SUBDIR
    DISTRO_NAME="Puppy_$DISTRO_VERSION"
  ;;
  *.sfs)
    DISTRO_NAME=$(basename $KBASE .sfs |tr '-' '_')
    [ "$SUBDIR" = "puppylivecdbuild" ] && DESTRO_NAME="${DISTRO_NAME}_custom"
  ;;
  menu.lst)
       DISTRO_NAME=$(grep -v '^[[:blank:]]*#' $TOPDIR$KEYFILE | grep '^[[:blank:]]*title'| head -n 1 | sed -e 's/^[[:blank:]]*title.//i')
       echo "$DISTRO_NAME" | grep -q 'find[[:blank:]]*/' && DISTRO_NAME=$(echo "$DISTRO_NAME" | cut -d'/' -f2)
  ;;
  *.cfg)
  #porteus.cfg
	DISTRO_NAME=""
	for W in title 'menu.label' label; do
		DISTRO_NAME=$(grep -i "$W" $TOPDIR$KEYFILE| head -n 1)
		if [ "$DISTRO_NAME" ]; then
			DISTRO_NAME=$(echo "$DISTRO_NAME" | sed -e 's/^.*'$W' //i')
			break
		fi
	done
  ;;
  initrd*|vmlinuz)
   # full installed Puppy
   [ -f $TOPDIR/etc/rc.d/PUPSTATE ] && DISTRO_NAME="Puppy"
   [ -f $TOPDIR/etc/puppyversion ] && DISTRO_NAME="Puppy" && DISTRO_VERSION="$(cat $TOPDIR/etc/puppyversion)" #old pre-w464 install.
   [ -f $TOPDIR/etc/DISTRO_SPECS ] && source $TOPDIR/etc/DISTRO_SPECS
   [ "$DISTRO_VERSION" != "" ] && DISTRO_NAME="$DISTRO_NAME $DISTRO_VERSION"
   [ "$DISTRO_NAME" ] && echo "$DISTRO_NAME" && return
   # other linux
   if [ "$DISTRO_NAME" = "" ]; then
     if [ -f $TOPDIR/etc/vine-release ] ; then
      DISTRO_NAME=$(head -n 1 $TOPDIR/etc/vine-release)
     elif [ -f $TOPDIR/etc/lsb-release ] ; then
       source $TOPDIR/etc/lsb-release
	 DISTRO_NAME=$DISTRIB_DESCRIPTION
     fi
     if [ "$DISTRO_NAME" = "" ]; then
       S="$SUBDIR"; [ "$S" ] && S="/$S"
       V=$(ls -1 "$TOPDIR$S"/vmlinuz-* 2>/dev/null|tail -n1)
       [ "$V" ] && DISTRO_NAME=$(basename "$V"| sed -e 's/vmlinuz/Linux/' | tr '.-' '_')
     fi
     if [ "$DISTRO_NAME" = "" ]; then
       DISTRO_NAME="Linux"
       [ "$SUBDIR" != "" ] && DISTRO_NAME="$DISTRO_NAME $SUBDIR"
     fi
   fi 
  ;;
  esac
  [ "$DISTRO_NAME" ] && echo "$DISTRO_NAME" || echo "Unknown"
}
part2drive() {
	sed -e 's/[0-9]*$//' -e 's/\([0-9]\)p$/\1/'
}
X=0
Y=0
partname2num() {
  [ "$1" ] && PART=$1
  DRIVE=$(echo $PART | part2drive) 
  Y=$(echo $PART | sed -e 's/^.*[a-z]//'| tr -dc '0-9') 
  [ "$Y" ] || Y=1
  [ "$COMPAT_MENU" ] || COMPAT_MENU=1
  [ $COMPAT_MENU -lt 2 ] && Y=$(expr $Y - 1)
  X=0
  [ "$DRIVE" = "$WHERETO" ] && return
  [ "$SWAPPED" != "" ] && return
  echo "$DRIVES" | grep -qw "$DRIVE" || return
  for L in $DRIVES
  do
    echo "$L" | grep -qw "$DRIVE" && break
    X=$(expr $X + 1)  
  done
  [ "$REPLACE" != "" ] && X=$(expr $X + 1)
}

swapping() {
  SWAPPED=""
  DRIVE=$(echo $1| part2drive)
  [ "$DRIVE" = "$TODRIVE" ] && return
  X=0
  case "$DRIVE" in
  *[0-9]) PART1="${DRIVE}p1" ;;
  *)      PART1="${DRIVE}1" ;;
  esac
  partname2num "$PART1"
  [ $X -eq 0 ] && return
  echo "  map (hd$X) (hd0)
  map (hd0) (hd$X)"
  SWAPPED="true"
  X=0
  [ "$LEGACY_MENU" = "true" ] && return
  echo "  map --hook"
}
setroot() {
	[ "$PBSINSTALL" != "" ] && return 1
	[ "$COMPAT_MENU" ] || COMPAT_MENU=1
	echo -n "  "
	[ "$1" ] && PART="$1"
	TYPE=$(echo "$PCPARTS"|grep -w "/dev/$PART"| cut -d'|' -f2)
	UUID=""
    if [ "$BULKIDS" != "" -a $COMPAT_MENU -gt 0 ] && echo $TYPE| grep -qE 'vfat|ntfs|ext'; then
      for W in $(echo "$BULKIDS"| grep -w "^/dev/$PART" | cut -d':' -f2);do
        echo $W|grep -qw 'UUID' || continue
        UUID=$(echo $W|cut -d'=' -f2| tr -d '"')
      done
    fi
    if [ "$UUID" != ""  ]; then
     [ $COMPAT_MENU -eq 2 ] && echo "search --no-floppy --fs-uuid --set=root $UUID" && return 0
     echo "uuid $UUID" && return 0
    fi
    if [ "$SEARCHPATH" ]; then
     [ $COMPAT_MENU -eq 1 ] && echo "find --set-root --ignore-floppies --ignore-cd $SEARCHPATH" && return 0
    fi
      X=0
      Y=0
      partname2num $PART
      [ $COMPAT_MENU -eq 2 ] && echo "set root='(hd$X,$Y)'" && return 0
      echo "root (hd$X,$Y)"
      return 0
}
trim() {
  read X
  echo $X
}

LABELS=""
unique() {
  mySUFF=0
  myLABEL="$L"
  while [ "$LABELS" != "" ] && echo "$LABELS" | grep -q "^$myLABEL$"
  do
    mySUFF=$(expr $mySUFF + 1)
    myLABEL="$L $mySUFF"
  done
  LABELS="$LABELS
$myLABEL"
  L="$myLABEL"
}

make_label() {
   P=$(echo $ITEM|cut -d'|' -f1|cut -d',' -f1)
   echo "$P" | grep -q '/' && P=$(dirname "/$P")
   P1=$(echo $P|cut -d'/' -f 2)
   P2=$(echo $P|cut -d'/' -f 3)
   P=$P1
   [ "$P2" != "" ] && P="$P1/$P2"
   L="$(echo $ITEM|cut -d'|' -f2 | tr '_' ' ')"
   L="$(echo $L|cut -c1|tr 'a-z' 'A-Z')$(echo $L|cut -c2-)"
   [ "$PBR" != "" ] && L="$L ($P1$PBR)" || L="$L ($P)"
}

kbyte2() {
	S=$1
	case $S in
	*GB) echo $S; return
	;;
	*MB) KB=$(($(echo $S| cut -d'.' -f1|tr -dc '0-9') * 1024))
	;;
	*) KB=$(echo $S|tr -dc '0-9')
	;;
	esac
	[ "$KB" = "" ] && KB=0 
	if [ $KB -lt 1024 ]
	then echo ${KB}kB; return
	fi
	MB=$(expr $KB / 1024)
	[ $MB -lt 1024 ] && echo "${MB}MB" || echo "$(dc $MB 1024 \/ p|sed -e 's/\(^.*\..\).*/\1/')GB"
}
error_missing() {
 local myFATAL=""
 case "$1" in
 *-fatal) shift; myFATAL="yes";;
 esac
 local myMSG="$1"
 local myMISSINGS="$2"
 BUTTONS='<button ok></button>'
 if [ "$myFATAL" != "" ]; then
  myFATAL="<text><label>$_Quit</label></text>"
 else
  BUTTONS='<button cancel></button>
    <button><input file stock="gtk-ok"></input><label>'$(echo 'Proceed anyway')'</label><action>EXIT:OK</action></button>'
 fi
 if [ "$myMISSINGS" != "" ]; then
   myMSG="$myMSG:$(echo $myMISSINGS| sed -e 's/ /, /'|tr '@' ' ')"
 fi
 [ $# -gt 2 ] && myMSG="$@"
 echo "$myMSG" >&2
 HELP_SECTION=""
 DIALOG="<window title=\"$_Title - Error\" icon-name=\"grub4dos-ui\"><vbox>
   <pixmap icon_size=\"5\">
    <input file stock=\"gtk-dialog-error\"></input>
   </pixmap>
 <frame>
 <text><input>echo -en \"$myMSG\"</input></text>
  </frame>
  $myFATAL
  <hbox>$BUTTONS</hbox>
  </vbox></window>"
 splash stop
 RET=$($GTKDIALOG -p DIALOG -c || echo "$DIALOG" >&2)
 [ "$FATAL" = "" ] || exit 1
 eval "$RET"
 [ "$EXIT" = "OK" ]
}

LAST_BOOT_PART_DRIVE=""
LAST_BOOT_PART=""
boot_part() {
  myDRIVEDEV=$(echo $1| part2drive)
  echo $myDRIVEDEV | grep -q '/' || myDRIVEDEV="/dev/$myDRIVEDEV"
  [ "$myDRIVEDEV" = "$LAST_BOOT_PART_DRIVE" ] && echo "$LAST_BOOT_PART" && return
  LAST_BOOT_PART_DRIVE=$myDRIVEDEV
  LAST_BOOT_PART=$(LANG=C fdisk -l $myDRIVEDEV| grep "^/dev/.*[*]" | cut -d' ' -f1| cut -d'/' -f3)
  echo $LAST_BOOT_PART
}
is_bootable() {
  DEV=$1
  echo $1 | grep -q '/' || DEV="/dev/$1"
  [ "$(hexdump -n 512 $DEV | tail -n 2 | head -n 1 | cut -d' ' -f9)" = "aa55" ] || return
  local myDRIVE=$(echo $DEV| part2drive)
  [ "$DEV" = "$myDRIVE" ] && return
  [ "$DEV" = "$(boot_part $DEV)" ] 
}
pmediaopt() {
  [ "$1" ] && DRIVE=$1
    PMEDIA="atahd"
    REMOVABLE="$(cat /sys/block/$DRIVE/removable)" 
    if [ "$REMOVABLE" = "1" ]; then
      PMEDIA="usbflash"
    else
      $PROBEDISK | grep "/dev/$DRIVE|" | grep -q -w 'SSD' && PMEDIA="ataflash"
    fi
    PMEDIAOPT="pmedia=$PMEDIA"
    echo $PMEDIAOPT
}

PARAM1=$1
PARAM2=$2
GTKDIALOG=gtkdialog
PROBEDISK=$(which probedisk)
export DIALOG=""
export XPID=""
export SMOUNTED=""
PATH=/usr/bin
APPLIBDIR=/usr/lib/grub4dos

if [ "$DISPLAY" = "" ]
then
	echo "$(basename $0) requires X running. Try 'startx' and re-run '$0'. Good bye."
	exit 1
fi

probing start
MISSINGS=""
for F in grldr; do
  [ -s "$APPLIBDIR/$F" ] || MISSINGS="$MISSINGS $APPLIBDIR/$F"
done
BINSTALLER=""
for P in bootlace.com grubinst ;do
  which $P &>/dev/null && BINSTALLER=$P && break
done
debug "BINSTALLER=$BINSTALLER"
[ "$BINSTALLER" != "" ]|| MISSINGS="$MISSINGS /usr/sbin/bootlace.com"
GRUBLOADER="grldr"
[ -s "$APPLIBDIR/$GRUBLOADER" ] || GRUBLOADER=""
ALLOW_PBS="no"
OPT=""
[ "$BINSTALLER" != "" -a "$GRUBLOADER" != "" ] || OPT="--fatal" 
HELP_SECTION=""
if [ "$MISSINGS" ]; then
  error_missing --fatal $OPT "$_Missing" "$MISSINGS"
  exit 1
fi
[ -f /etc/rc.d/PUPSTATE ] && . /etc/rc.d/PUPSTATE
MYSFSFILE=$(echo $PUPSFS|cut -d',' -f3)
MYSFSBASE=$(basename "$MYSFSFILE")
PUPPYPREFIX=$(echo $MYSFSBASE|sed -e 's/[0-9].*$//')
MYPART=$(echo $PUPSFS|cut -d',' -f1)
MYDRIVE=$(echo $MYPART| part2drive)
MYPUPPY=$MYPART$MYSFSFILE

# where to install
DISKS=$(probedisk)
PBS_SUPPORT=""
LOCAL_SEARCH=""
PLOCAL=""
[ "$PARAM1" = "PBS" ] && PBS_SUPPORT="yes" && PARAM1="" 
echo $PARAM1 | grep -q '^/dev/' && PARAM1=$(echo $PARAM1| cut -f3 -d'/')
[ "$PARAM2" != "" ] && LOCAL_SEARCH="yes"
[ "$ALLOW_PBS" = "yes" ] || PBS_SUPPORT=""
BULKIDS=""
which blkid &>/dev/null && BULKIDS=$(blkid)
PCPARTS=$(probepart -k|grep -E 'vfat|ntfs|ext|reiserfs'| sort -k 1.6,1.8 -k 1.9n,1 -t'|')
PLACELIST=""
NOWDRIVE=""
DRIVES=""
FIRSTDRIVE=""
for L in $PCPARTS
do
  PART=$(echo $L|cut -d '|' -f 1 | cut -d '/' -f 3)
  TYPE=$(echo $L|cut -d '|' -f 2)
  DRIVE=$(echo $PART| part2drive)
  if [ "$DRIVE" != "$NOWDRIVE" ]; then
    DRIVESIZE=$(LANG=C fdisk -l /dev/$DRIVE| cut -s -d':' -f2| head -n 1| cut -d',' -f1| tr -d ' ')
    DRIVEINFO=$(echo "$DISKS"|grep "^/dev/$DRIVE|"| cut -d '|' -f 3|tr ' ' '_')
    DRIVEINFO="$DRIVESIZE"_"$DRIVEINFO"
    if [ "$NOWDRIVE" = "" ]; then
      FIRSTDRIVE="$DRIVE"
	  DRIVES="$DRIVE"
      PLACELIST="${DRIVE}|$DRIVEINFO"
      if [ -b /dev/fd0 ]; then
        PLACELIST="$PLACELIST
fd0|FLOPPY_DISK"
      fi
    else
	  DRIVES="$DRIVES
$DRIVE"
      PLACELIST="$PLACELIST
${DRIVE}|$DRIVEINFO"
    fi
    NOWDRIVE=$DRIVE
  fi
  if [ "$PBS_SUPPORT" = "yes" ]; then
    KFULL=$(echo $L|cut -d '|' -f 3)
    ALINE=$(echo "$BULKIDS"| grep "^/dev/$PART:")
    LABEL=""
    for ITEM in $ALINE; do
      echo $ITEM | grep -q 'LABEL=' && LABEL=$(echo $ITEM| cut -d'=' -f2| tr -d '"')
    done
    PLACELIST="$PLACELIST
${PART}|(${TYPE})_$(kbyte2 $KFULL)_$LABEL"
  fi
done
[ "PLACELIST" = "" ] && [ -b /dev/fd0 ] && PLACELIST="fd0|FLOPPY_DISK"
if [ "$PARAM1" != "" ]; then
  FIRSTLINE=$(echo "$PLACELIST"| grep -w "^${PARAM1}")
  PLACELIST="$FIRSTLINE
$(echo -e "$PLACELIST"| grep -v "^${PARAM1}_")"
else
  LACELIST=$(echo -e "$PLACELIST")
fi
debug "$PLACELIST"
DEFAULTDRIVE=$(echo "$PLACELIST" | head -n1 | cut -f1 -d'|')
SEARHDEFALT=""
[ "$LOCAL_SEARCH" != "" ] && SEARCHDEFAULT="<default>true</default>"
DIALOG="<window title=\"$_Title\" icon-name=\"grub4dos-ui\" width-request=\"750\"><vbox>
  <text><label>Grub4DOS UI v.$MYVERSION</label></text>
  <hbox>
  <frame $_Where>
   <text><label>\"$_Where2\"</label></text>
   <tree tooltip-text=\"$_Where_tip\">
   <variable>WHERETO</variable>
   <label>\"$_Device|$_Information\"</label>"
for ITEM in $PLACELIST
do
  DIALOG="$DIALOG
  <item>$(echo $ITEM | tr '_' ' ')</item>"
done
PBSBUTTON=""
SHOWPBS=$(echo 'Refresh')
TIPS=$(echo 'Probe devices again.')
LOCALTIP="$_SearchOnly_tip $_Ignored"
[ "$PBS_SUPPORT" = "yes" ] && LOCALTIP="$_SearchOnly_tip $_Forced $_Ignored"
LEGACY_MENU='false'
if [ "$ALLOW_PBS" = "yes" -a  "$PBS_SUPPORT" != "yes" ]; then
  SHOWPBS=$_Show_partition
  TIPS=$_Show_partition_tip
fi
PBSBUTTON="<button tooltip-text=\"$TIPS\"><input file stock=\"gtk-refresh\"></input><label>$SHOWPBS</label><action>EXIT:REFRESH</action></button>"
DIALOG="$DIALOG
  </tree></frame>
  <frame $(echo 'Options')>
  <vbox>
  <checkbox tooltip-text=\"$LOCALTIP\"><label>$_SearchOnlyD</label><default>true</default><variable>LOCAL_SEARCH</variable>$SEARCHDEFAULT</checkbox>
  <checkbox tooltip-text=\"$_KeepMenu_tip\"><label>$_KeepMenu</label><variable>KEEP_MENU</variable></checkbox>
  <checkbox tooltip-text=\"$_Single_page_menu_tip\"><label>$_Single_page_menu</label><variable>ONEPAGE_MENU</variable></checkbox>
  <checkbox tooltip-text=\"$_LegacyMenu_tip\"><label>$_LegacyMenu</label><variable>LEGACY_MENU</variable></checkbox>
  <checkbox tooltip-text=\"$_Keep_tip\"><label>$_Keep</label><variable>KEEP_BOOT_RECORD</variable></checkbox>
  <hbox>
  <button tooltip-text=\"$_online\"><input file stock=\"gtk-info\"></input><label>$_More_info</label><action>$BROWSER $_WebPage &</action></button>
  </hbox>
  </vbox></frame>
  </hbox>
  <text><label>$_Welcome2</label></text>
  <hbox>
  <button ok></button>
  $PBSBUTTON
  <button cancel></button>
  </hbox>
  </vbox></window>"
probing end
eval $($GTKDIALOG -p DIALOG -c | grep '^\w\w*=' || echo "$DIALOG" >&2)
[ "$EXIT" = "REFRESH" ] && exec $0 PBS
[ "$EXIT" = "OK" ] || exit 0
MBR=""
REPLACE=""
FLOPPY=""
PBSINSTALL=""
BOOTLOADER=""
COMPAT_MENU=1
[ "$LEGACY_MENU" = 'true' ] && COMPAT_MENU=0
WHERETO=$(echo $WHERETO| sed -e 's/[^0-9a-z].*$//')
[ "$WHERETO"  ] || WHERETO=$DEFAULTDRIVE
if echo $WHERETO | grep -qw "^$FIRSTDRIVE" ; then
  MBR="(MBR)"
elif echo $WHERETO | grep -qw 'fd0' ; then
  FLOPPY="(FLOPPY DISK)"
fi
if [ "$FLOPPY" != "" ]; then
  LPART="fd0|vfat"
  LOCAL_SEARCH="false"
  KEEP_BOOT_RECORD="false"
  KEEP_MENU="false"
  BOOTLOADER="bootlace.com"
  TODRIVE="fd0"
else
  DRIVE=$(echo $WHERETO | part2drive)
  DPARTS=$(echo "$PCPARTS"|grep "/$DRIVE")
  TODRIVE=$DRIVE
  if echo $WHERETO | grep -q [0-9]; then
    PBSINSTALL="yes"
    [ "$LOCAL_SEARCH" = "true" ] && PLOCAL="yes"
    DPARTS=$(echo "$PCPARTS" | grep -w "$WHERETO")
  fi
  LPART=$(echo "$DPARTS"| grep -E 'vfat|ntfs|ext' | head -n 1 | cut -d ' ' -f 1)
  if [ "$LPART" = "" ]; then
    debug "WHERETO=$WHERETO;"
     PARTS=$(probepart| grep "/$WHERETO"|sed -e 's/[0-9]*$//')
     PARTS=$(echo $PARTS|sed -e 's/ /\\n/')
     debug "$PARTS"
     HELP_SECTION=""
     error_missing --fatal "$_NoSupport:\n$PARTS"
     exit 1
  fi
  if [ "$KEEP_BOOT_RECORD" = "true" -a "$KEEP_MENU" = "true" ]; then
    error_missing "$_Notask" || exit 0
    exec $0 "$@"
  fi
  [ "$LOCAL_SEARCH" = "true" ] && PCPARTS="$DPARTS"
  [ "$DRIVE" != "$FIRSTDRIVE" ] && REPLACE="yes"
  [ "$FLOPPY" = "" ] && TOREMOVABLE=$(cat /sys/block/$TODRIVE/removable) || TOREMOVABLE="0"
  if [ "$MBR" = ""  -a "$LOCAL_SEARCH" != "true" ]; then
   TOPARTS=$(echo "$PCPARTS"| grep "^/dev/$TODRIVE")
    PCPARTS="$TOPARTS
 $(echo "$PCPARTS"| grep -v "^/dev/$TODRIVE")"
  fi
  debug "PCPARTS:
$PCPARTS
"
 if [ "$KEEP_BOOT_RECORD" != "true" ]; then
   debug "LPART:$LPART"
   TYPE=$(echo $LPART | cut -d'|' -f2)
   BOOTLOADER="bootlace.com"
   if [ "$TYPE" = "ext4" ]; then
     if [ "$PBSINSTALL" != "" ]; then
       BOOTLOADER="extlinux"
     else
       BOOTLOADER="wee"
     fi
   fi
 fi
 if [ "$BOOTLOADER" = "extlinux" ] ; then
	  MISSINGS=""
	  CHAINLOADER=""
	  for D in /usr/lib/syslinux $APPLIBDIR; do
	    [ -s "$D/chain.c32" ] && CHAINLOADER="$D/chain.c32" && break
	  done
	  debug "CHAINLOADER=$CHAINLOADER"
	  [ "$CHAINLOADER" != "" ] || MISSINGS="$APPLIBDIR/chain.c32"
	  MVER=$(extlinux --version 2>&1| tr -s ' '| cut -d' ' -f2| cut -d'.' -f1| tr -dc '0-9')
	  [ "$MVER" != "" ] || MVER=0
	  if [ $MVER -lt 4 ]; then
	    BOOTLOADER=""
	    MISSINGS="$MISSINGS extlinux/syslinux(version@>=@4.0)"
	  fi
	  HELP_SECTION=""
	  [ "$MISSINGS" = "" ] || error_missing --fatal "$_Lacking" "$MISSINGS"
 fi
 if [ "$BOOTLOADER" = "wee" ] ; then
   if [ ! -s "$APPLIBDIR/wee.mbr" ]; then
     HELP_SECTION=""
     error_missing --fatal "$_Lacking" "$APPLIBDIR/wee.mbr"
   fi
   S=$(LANG=C fdisk -u -l /dev/$DRIVE | grep -w "^/dev/$PART"| tr -d '*'| tr -s ' '| cut -d' ' -f2 | tr -dc '0-9')
   debug "The first partition starts from: $S(LBA)"
   [ "$S" != "" ] || S=63
   if [ $S -lt 63 ] ; then
      HELP_SECTION=""
      error_missing --fatal "$_SPT_Err1 $_SPT_Drive: '$DRIVE' $_SPT_Sector= $SPT\n$_SPT_Err2 $_SPT_Err3"
      exit 1
   fi
 fi
fi
if [ "$FLOPPY" = "" ]; then 
  if [ "$(boot_part $TODRIVE)" = "" ]; then
    HELP_SECTION="bootflag"
    error_missing $(printf "$(echo 'Boot flag not found on %s.')" $TODRIVE)'\n'\
$(echo "Some BIOS does not boot from the drive which has no boot flag. Click 'Cancel' here and set the boot flag by using GParted or something. But you can proceed installing grub4dos first.") || exit
  fi
fi
if [ "$KEEP_MENU" = "true" ]; then
  probing start
  MENUFILE=""
  for L in $PCPARTS
  do
    mountpoint $L || continue
    TOPDIR=$MP
    for D in /  /boot/grub /grub; do
      [ "$D" = "/" ] && MENUFILE="$TOPDIR/menu.lst" || MENUFILE="$TOPDIR$D/menu.lst"
      [ -s "$MENUFILE" ] && break
      MENUFILE="" 
    done
    [ "$MENUFILE" != "" ] && break
  done
  MENUFILE=$(echo "$MENUFILE"|sed -e "s,^$TOPDIR/,$PART/,")
  NEWMENU="$(echo $LPART | cut -d'|' -f1| cut -d'/' -f3)/menu.lst"
  if [ "$MENUFILE" != "$NEWMENU" ]; then
    KEEP_MENU="false"
    if [ "$MENUFILE" != "" ]; then
      debug "'$MENUFILE' found."
      MSG="$_Anothermenu_W: $MENUFILE"
    else
      debug "'menu.lst' not found."
      MSG="$_Nomenu_W"
    fi
    MSG="\\n$MSG\\n$_Nomenu_new: $NEWMENU\\n$_Nomenu_cont"
    DIALOG="<window title=\"$_Title\" icon-name=\"grub4dos-ui\"><vbox>
   <frame Warning>
   <hbox>
     <pixmap icon_size=\"5\">
       <input file stock=\"gtk-dialog-warning\"></input>
     </pixmap>
     <text><input>echo -en \"$MSG\"</input></text>
   </hbox>
   <checkbox tooltip-text=\"$_KeepMenu_tip\"><label>$_KeepMenu</label><variable>KEEP_MENU</variable></checkbox>
 </frame>
  <hbox>
   <button ok></button>
   <button cancel></button>
  </hbox>
  </vbox></window>"
    probing stop
    RET=$($GTKDIALOG -p DIALOG -c | grep -E '^[A-Z_]*=' || echo "$DIALOG" >&2)
    eval "$RET"
    [ "$EXIT" = "OK" ] || exit 0
  fi
  probing stop
fi

if [ "$KEEP_MENU" != "true" ] ; then
probing start
LC_ALL_SAVE=$LC_ALL
LC_ALL=C
PUPPIES=""
FULLINSTS=""
MENULSTS=""
WININTS=""
CHAINS=""
BOOTMGRS=""
DUP=""
 BOOTPARTS=""
 if [ "$PBSINSTALL" = "" ]; then
  DRVS=$DRIVES
  [ "$LOCAL_SEARCH" = "true" ] && DRVS=$TODRIVE
  for D in $DRVS; do
   B=$(fdisk -l /dev/$D| grep -E "^/dev/$D.*[*]") || continue
   B=$(echo $B| cut -d' ' -f1| cut -d'/' -f3)
   BOOTPARTS="$BOOTPARTS
$B"
  done
 fi
for L in $PCPARTS
do
  mountpoint $L || continue
  TOPDIR=$MP
  KEYFILE=""
  # Puppy
  PUPDIRS=$(ls $TOPDIR/initrd.[gx]z $TOPDIR/*/initrd.[lgx]z   2>/dev/null | sed -e 's,/initrd..z$,,')
  for D in $PUPDIRS
  do
	[ -f $D/vmlinuz ] || continue
    INITRDGZ=$(basename "$(ls -1 $D/initrd.[lgx]z 2>/dev/null | tail -n1)")	#3jun12 v1.7.9.x, v1.8: revert
    PUPSFS="$D/puppy.sfs"; [ -s "$PUPSFS" ]  || PUPSFS=""
	[ "$PUPSFS" = "" ] && [ "$PUPPYPREFIX" != "" ] && PUPSFS="$(ls $D/$PUPPYPREFIX[0-9][0-9][0-9]*.sfs 2>/dev/null|tail -n 1)"
	[ "$PUPSFS" = "" ] && PUPSFS="$(ls $D/pup[_-][0-9][0-9][0-9]*.sfs 2>/dev/null|tail -n 1)"
	[ "$PUPSFS" = "" ] && PUPSFS="$(ls $D/?pup-[0-9][0-9][0-9]*.sfs 2>/dev/null|tail -n 1)"
	[ "$PUPSFS" = "" ] && PUPSFS="$(ls $D/[b-yA-Z][0-9a-zA-Z][0-9a-zA-Z][-_][0-9][0-9][0-9].sfs 2>/dev/null|tail -n 1)"
	[ "$PUPSFS" = "" ] && PUPSFS="$(ls $D/[b-yA-Z][0-9a-zA-Z][0-9a-zA-Z][0-9a-zA-Z][-_][0-9][0-9][0-9].sfs 2>/dev/null|tail -n 1)"
	[ "$PUPSFS" = "" ] && PUPSFS="$(ls $D/[b-yA-Z][0-9a-zA-Z]*[-_][0-9][0-9][0-9].sfs 2>/dev/null|tail -n 1)"
	[ "$PUPSFS" = "" ] && PUPSFS="$(ls $D/[b-yA-Z][0-9a-zA-Z]*[-_][0-9]*.sfs 2>/dev/null|tail -n 1)"
	if [ "$PUPSFS" != "" ]; then
	  KEYFILE=$(echo "$PUPSFS"|sed -e "s,^$TOPDIR/,/,")
	  PDIR=$(echo "$KEYFILE"| cut -s -d '/' -f 2)
	  [ "$PDIR" ] && echo "$PUPPIES"| grep -q "/$PDIR/" && DUP="$DUP $PDIR"
	  ITEM="$PART$KEYFILE,$INITRDGZ|$(read_distro_specs $TOPDIR)"
	  PUPPIES="$PUPPIES
$ITEM"
    else
      KEYFILE=$(echo "$D/$INITRDGZ,$D/vmlinuz"|sed -e "s,$TOPDIR/,/,g")
      ITEM="$PART$KEYFILE|$(read_distro_specs $TOPDIR)"
    FULLINSTS="$FULLINSTS
$ITEM"
    fi
  done
  ROOTPUPPY=$(echo "$PUPPIES" | grep -E "^$PART/[^/]*.sfs" | tail -n 1)
  # kernel
  for BOOTDIR in / /boot; do
    [ "$BOOTDIR" = "/boot" ] && BOOT=boot/ || BOOT="" 
    K=$(cd $TOPDIR; ls -1 ${BOOT}vmlinuz* 2>/dev/null) || continue
    if [ $(echo "$K"| wc -l) -eq 1 ]; then
      KEYFILE=$K
    else
      KEYFILE=$(echo "$K" | grep 'vmlinuz$')
      [ "$KEYFILE" ] || KEYFILE=$(echo "$K"| grep -vw 'old'| tail -n 1)
      [ "$KEYFILE" ] || KEYFILE=$(echo "$K"| tail -n 1 )
    fi
    [ "$KEYFILE" ] || continue
    [ "$(echo "$KEYFILE" | cut -c 1)" != "/" ] && KEYFILE="/$KEYFILE"
    VMBASE=$(basename "$KEYFILE")
    VMSUFFIX=$(echo $VMBASE| sed -e 's/^vmlinuz//')
    if [ -f $TOPDIR/${BOOT}vmlinuz ]; then
      KEYFILE=/${BOOT}vmlinuz
      for F in /${BOOT}initrd.lz /${BOOT}initrd.xz /${BOOT}initrd.gz /${BOOT}initrd.img /${BOOT}initrd /${BOOT}bzImage /grub/menu.lst
      do [ -f $TOPDIR$F ] && KEYFILE="$F,$KEYFILE" && break
      done
    else
      for F in /$(cd $TOPDIR; ls -1 ${BOOT}initrd$VMSUFFIX* ${BOOT}bzImage$VMSUFFIX 2>/dev/null; ls -1 ${BOOT}initrd* ${BOOT}bzImage* 2>/dev/null| grep -v 'old' tail -n 1; ls -1 ${BOOT}initrd* ${BOOT}bzImage* 2>/dev/null| tail - 1) /grub/menu.lst
      do [ -f $TOPDIR$F ] && KEYFILE="$F,$KEYFILE" && break
      done
    fi
    if [ "$ROOTPUPPY" ] && echo "$KEYFILE" | grep -qx '/initrd.[lgx]z,/vmlinuz'; then
      KEYFILE="/$(echo $ROOTPUPPY| cut -d'/' -f2)"
    else
      ITEM="$PART$KEYFILE|$(read_distro_specs $TOPDIR)"
      FULLINSTS="$FULLINSTS
$ITEM"
    fi
    break
  done

  # alphaos
  for D in $ALPHAOS_DIRNAMES; do
    if [ -f $TOPDIR/$D/boot/vmlinuz -a -f $TOPDIR/$D/alpha*sb ];then
      KEYFILE="/$D/boot/initrfs.img,/$D/boot/vmlinuz"
      ITEM="$PART$KEYFILE|$(read_distro_specs $TOPDIR)"
      FULLINSTS="$FULLINSTS
      $ITEM"
    fi
  done
  
  # Wubi
  if [ -f $TOPDIR/ubuntu/disks/boot/grub/menu.lst ];then 
    KEYFILE=/ubuntu/disks/boot/grub/menu.lst
    ITEM="$PART$KEYFILE|$(read_distro_specs $TOPDIR)"
    FULLINSTS="$FULLINSTS
$ITEM"
  fi
  for D in ubuntu jolicloud; do
   if [ -f $TOPDIR/$D/winboot/wubildr.mbr ];then
    KEYFILE=/$D/winboot/menu.lst
    ITEM="$PART$KEYFILE|$(read_distro_specs $TOPDIR)"
    FULLINSTS="$FULLINSTS
$ITEM"
   fi
  done
  if [ -f $TOPDIR/ubnldr.mbr -a -f $TOPDIR/unetbtin/menu.lst ];then
    KEYFILE=/unetbtin/menu.lst
    ITEM="$PART$KEYFILE|$(read_distro_specs $TOPDIR)"
    FULLINSTS="$FULLINSTS
$ITEM"
  fi
  # slitaz
  SLITAZES=$(find -L $TOPDIR -mindepth 1 -maxdepth 2 -name rootfs*.gz -type f| rev | cut -f2- -d'/' | rev| sort -u)
  if [ "$SLITAZES" ]; then
    for D in $SLITAZES; do
      [ -s "$D/bzImage" ] || continue
      S=$(echo $D| sed -e "s,^$TOPDIR,,")
      if [ -s "$D/rootfs.gz" ]; then
        ROOTFSES="rootfs.gz"
      else
        ROOTFSES=$(find -L $D -mindepth 1 -maxdepth 1 -name rootfs[1-9].gz -type f -printf ',%P' | cut -b2-)
      fi
      KEYFILE="$S/$ROOTFSES"
      ITEM="$PART$KEYFILE|$(read_distro_specs $TOPDIR)"
      FULLINSTS="$FULLINSTS
$ITEM"
    done
  fi
  # porteus
  if [ -d $TOPDIR/porteus -a -f $TOPDIR/boot/syslinux/porteus.cfg ]; then
    KEYFILE="/boot/syslinux/porteus.cfg"
    ITEM="$PART$KEYFILE|$(read_distro_specs $TOPDIR)"
    FULLINSTS="$FULLINSTS
$ITEM"
	mkdir -p "$(dirname "$APPTMP/$PART$KEYFILE")"
	cp "$TOPDIR$KEYFILE" "$APPTMP/$PART$KEYFILE"
  fi
  # fatdog
  INITRDS=$(find -L $TOPDIR -mindepth 2 -maxdepth 2 -name initrd -type f)
  if [ "$INITRDS" ]; then
    for P in $INITRDS; do
      D=$(dirname "$P")
      [ -s "$D/vmlinuz" ] || continue
      S=$(echo $D| sed -e "s,^$TOPDIR,,")
      KEYFILE="$S/initrd,$S/vmlinuz"
      ITEM="$PART$KEYFILE|$(read_distro_specs $TOPDIR)"
    FULLINSTS="$FULLINSTS
$ITEM"
    done
  fi
  MENUS=$(ls $TOPDIR/menu.lst $TOPDIR/boot/grub/menu.lst $TOPDIR/grub/menu.lst 2>/dev/null)
  if [ "$MENUS" ]; then
    for MENU in $MENUS; do
      KEYFILE=$(echo $MENU | sed -e "s,^$TOPDIR/,/,")
      ITEM="$PART$KEYFILE|$(read_distro_specs $TOPDIR)"
      MENULSTS="$MENULSTS
$ITEM"
    done
  fi
  for F in bootmgr ntldr io.sys ; do
    if [ -f $TOPDIR/$F ]; then
      KEYFILE="/$F"
      ITEM="$PART$KEYFILE|$(read_distro_specs $TOPDIR)"
      WININSTS="$WININSTS
$ITEM"
      break
    fi
  done
  if echo "$BOOTPARTS" | grep -qw "$PART" || is_bootable $PART; then
      ITEM="$PART$KEYFILE|$(read_distro_specs $TOPDIR)"
      CHAINS="$CHAINS
$ITEM"
  fi
  # plop
  if [ "$PLOPINSTS" = "" ]; then
   KEYFILE=""
   for D in /boot/ /; do
    F="${D}plpbt.bin"
    [ -s $TOPDIR$F ] && KEYFILE="$F" && break
   done
   if [ "$KEYFILE" != "" ]; then
     ITEM="$PART$KEYFILE|$(read_distro_specs $TOPDIR)"
     BOOTMGRS="$BOOTMGRS
$ITEM"
   fi
  fi
  KEYFILE=""
  umountmine
done
# fatdog64
FATDOGS=$(echo "$FULLINSTS"| grep  '/initrd,')
if [ "$FATDOGS" ]; then
  FULLINSTS=$(echo "$FULLINSTS"| grep -v '/initrd,')
  PUPPIES="$PUPPIES
$FATDOGS"
fi
PUPPIES=$(echo "$PUPPIES"| grep '/')
FULLINSTS=$(echo "$FULLINSTS"| grep '/')
MENULSTS=$(echo "$MENULSTS"| grep '/')
WININSTS=$(echo "$WININSTS"| grep '/')
CHAINS=$(echo "$CHAINS" | grep '|')
BOOTMGRS=$(echo "$BOOTMGRS"| grep 'plpbt.bin'| head -n 1)
PUPPYDRIVE=$(echo "$PUPPIES"| cut -d'/' -f1| part2drive | uniq)
if [ $(echo "$PUPPYDRIVE" | wc -l) -eq 1 ]; then
    PMEDIAOPT=$(pmediaopt $PUPPYDRIVE)
    PUPPYOPTIONS="$PMEDIAOPT $PUPPYOPTIONS"
fi

NPUP=$(echo "$PUPPIES"| wc -l)
if [ "$MYPUPPY" = "" ]; then
  [ -s /etc/DISTRO_SPECS ] && source /etc/DISTRO_SPECS
  [ "$DISTRO_NAME" = "Fatdog64" ] && MYPUPPY="Fatdog64"
fi 
if [ "$MYPUPPY" != "" -a $NPUP -gt 1 ]; then
  MYPUPPY=$(echo "$PUPPIES"| grep -w "$MYPUPPY" | head -n 1)
  [ "$MYPUPPY" = "" ] && MYPUPPY=$(echo "$PUPPIES"| grep -w $(basename "/$MYPUPPY") | head -n 1)
  [ "$FLOPPY" = "" ] && TOREMOVABLE=$(cat /sys/block/$TODRIVE/removable) || TOREMOVABLE="0"
  [ "$(echo $MYDRIVE| cut -b2)" = "d" ] && MYREMOVABLE=$(cat /sys/block/$MYDRIVE/removable)|| MYREMOVABLE="1"
  [ "$MYPUPPY" = "" ] && MYPUPPY=$(echo "$PUPPIES"| grep -Ew "^$TODRIVE.*$MYSFSBASE"| head -n 1)
  if [ "$MYPUPPY" = "" -a "$TOREMOVABLE" = "0" ]; then  
      for P in $(echo "$PUPPIES"| grep -w "$MYSFSBASE"); do
          D=$(echo $P|cut -d'/' -f1| tr -d '0-9')
          [ "$(cat /sys/block/$D/removable)" = "0" ] && MYPUPPY=$P && break
      done
  fi
  if [ "$MYPUPPY" != "" ]; then
    PUPPIES=$(echo "$PUPPIES"| grep -vx "$MYPUPPY")
    PUPPIES="$MYPUPPY
$PUPPIES"
  fi
  if [ "$TOREMOVABLE" = "1" -o "$MYREMOVABLE" = "1" ]; then
    MYPUPPY=$(echo "$PUPPIES"| grep -Ew "^$TODRIVE.*$MYSFSBASE"| head -n 1)
    [ "$MYPUPPY" = "" ] && MYPUPPY=$(echo "$PUPPIES"| grep "^$TODRIVE"| head -n 1)
    if [ "$MYPUPPY" != "" ]; then
      PUPPIES=$(echo "$PUPPIES"| grep -vx "$MYPUPPY")
      PUPPIES="$MYPUPPY
$PUPPIES"
    fi
  fi
fi
PUPPIES=$(echo "$PUPPIES"| grep '/')
debug "$PUPPIES"
debug "$FULLINSTS"
debug "$WININSTS"
debug "$MENULSTS"
debug "$CHAINS"
debug "$BOOTMGRS"
LC_ALL=$LC_ALL_SAVE

if [ "$DUP" != "" ]; then
 DUPS=""
 for PDIR in $DUP
 do
    DUPFILES=$(echo -e "$PUPPIES"|grep  "^[^/]*/$PDIR/")
    for F in $DUPFILES
    do
      ONEDUP=$(echo $F| sed -e 's,/[^/]*$,,')
      DUPS="$DUPS
   <text><label>$ONEDUP</label></text>"
   done
 done
 DIALOG="<window title=\"$_Title\" icon-name=\"grub4dos-ui\"><vbox>
   <frame Warning>
   <hbox>
     <pixmap icon_size=\"5\">
       <input file stock=\"gtk-dialog-warning\"></input>
     </pixmap>
     <text><input>echo -en \"$_Duplicated_W\"</input></text>
   </hbox>
  $DUPS
  </frame>
  <hbox>
   <button ok></button>
   <button cancel></button>
  </hbox>
  </vbox></window>"
 probing end
 RET=$($GTKDIALOG -p DIALOG -c | grep -E '^[A-Z]*=')
 eval "$RET"
 [ "$EXIT" = "OK" ] || exit 0
fi

PBR=""
 NPUP=0
 FRAME="<frame $_Frugal><vbox>"
if [ "$PUPPIES" = "" ];then
  FRAME="$FRAME
  <text><label>($_Not_found)</label></text>"
else
  NPUP=$(echo "$PUPPIES" | wc -l)
 I=0
 for ITEM in $PUPPIES
 do
  I=$(expr $I + 1)
  make_label
  FRAME="$FRAME
  <entry><variable>Frugal_$I</variable><default>$L</default></entry>"
 done
  FRAME="$FRAME
  <hbox>
  <text><label>$_Puppy_opt</label></text>
  <entry tooltip-text=\"$_Puppy_opt_tip\"><variable>PUPPYOPTIONS</variable><input>echo -en \"$PUPPYOPTIONS\"</input></entry>
  </hbox>
"
fi
 FRUGALFRAME="$FRAME
   </vbox></frame>"

FULLFRAME=""
NFULL=$(echo "$FULLINSTS" | wc -l)
NFULL=0
if [ "$FULLINSTS" != "" ];then
  NFULL=$(echo "$FULLINSTS" | wc -l)
 ADDOPT=""
 FRAME="<frame $_Full><vbox>"
 I=0
 for ITEM in $FULLINSTS
 do
   I=$(expr $I + 1)
   make_label
   FRAME="$FRAME
  <entry><variable>Full_$I</variable><default>$L</default></entry>"
 done
  FULLFRAME="$FRAME
  <hbox>
  <text><label>$_Linux_opt</label></text>
  <entry tooltip-text=\"$_Linux_opt_tip\"><variable>LINUXOPTIONS</variable><input>echo -en \"$LINUXOPTIONS\"</input></entry>
  </hbox>
 </vbox></frame>"
fi

FRAME=""
NWIN=$(echo "$WININSTS" | wc -l)
NWIN=$(($NWIN + 1))
  FRAME="$FRAME
  <text><input>echo -en \"$_Win3\"</input></text>
  <entry><variable>Win_0</variable><default>Windows</default></entry>"
if [ $NWIN -gt 1 ]; then
  I=0
  for ITEM in $WININSTS; do
  debug "WIN:$ITEM"
    I=$(($I + 1))
    make_label
    FRAME="$FRAME
   <entry><variable>Win_$I</variable><default>$L</default></entry>"
  done
fi
if [ "$FRAME" != "" ]; then
 WINFRAME="<frame $_Win><vbox>
$FRAME
  </vbox></frame>"
fi
NWIN=$(($NWIN + 1))

# main frame
[ $NWIN -eq 1 ] && NWIN=2
NL=$NPUP
NR=$(expr $NWIN + 2)
echo "$NPUP:$NFULL:$NWIN"
LFRAMES="$FULLFRAME"
RFLAMES=""
[ $NWIN -gt 0 ] && RFRAMES="$WINFRAME"
if [ $NFULL -gt 0 -a $NL -lt $NR ]; then
  LFRAMES="$LFRAMES
  $FRUGALFRAME"
elif [ $NFULL -gt 0 ]; then
  RFRAMES="$FRUGALFRAME
  $RFRAMES"
fi
RFRAME=""
if [ "$RFRAMES" != "" ]; then
  RBOX="<vbox>
  $RFRAMES
  </vbox>"
fi
DIALOG="<window title=\"$_Title - $_List\" icon-name=\"grub4dos-ui\"><vbox>
 <hbox>
   <vbox>
     <text><input>echo -en \"$_List2\"</input></text>
     $LFRAMES
   </vbox>
    $RBOX
 </hbox>
  <hbox>
   <button ok></button>
   <button cancel></button>
  </hbox>
</vbox></window>"
probing end
[ "$DEBUGFLAG" ] && echo "$DIALOG" > /tmp/grub4dosconfig-dialog
eval $($GTKDIALOG -p DIALOG -c | grep '^\w\w*=' || debug "$DIALOG")
[ "$EXIT" = "OK" ] || exit 0
fi

# confirm
MORE=""
[ "$KEEP_BOOT_RECORD" = "true" ] && MORE="$MORE
<text><label>$_Keep</label></text>"
[ "$KEEP_MENU" = "true" ] && MORE="$MORE
<text><label>$_KeepMenu</label></text>"

if [ "$FLOPPY" != "" ]; then
 LOAD_FLOPPY="<hbox>
    <pixmap>
    <input file icon=\"media-floppy\"></input>
   </pixmap>
   <text><label>$_Floppy</label></text>
   </hbox>"
 MORE="$MORE
 $LOAD_FLOPPY"
fi
DIALOG="<window title=\"$_Title - $(echo 'Confirmation')\" resizable=\"false\"><vbox>
    <frame $_Comfirm>
   <text use-markup=\"true\"><label>\"$_Comfirm1: <b>$WHERETO$MBR$FLOPPY</b>\"</label></text>
   $MORE
   </frame>
   <text><label>$_Comfirm3</label></text>
  <hbox>
   <button ok></button>
    <button cancel></button>
  </hbox>
  </vbox></window>"
eval $($GTKDIALOG -p DIALOG -c | grep '^\w\w*=')
[ "$EXIT" = "OK" ] || exit 0

# floppy
if [ "$FLOPPY" != "" ]; then
  splash start "$_Formating"
  ERRMSG="<window title=\"$_Title - Error\"><vbox>
   <pixmap icon_size=\"5\">
    <input file stock=\"gtk-dialog-error\"></input>
   </pixmap>
   <frame>$LOAD_FLOPPY</frame>
   <text><label>$_Comfirm3</label></text>
  <hbox>
   <button ok></button>
    <button cancel></button>
  </hbox>
  </vbox></window>"
 HAS_MKFS_MSDOS=""
 which mkfs.msdos &>/dev/null && HAS_MKFS_MSDOS="yes"
 if [ "$HAS_MKFS_MSDOS" != "" ]; then
  SUCCESS=""
  while [ "$SUCCESS" = "" ]; do
    mount | grep -q '^/dev/fd0[ ]' && umount /dev/fd0 &>/dev/null
    debug "mkfs.msdos -c /dev/fd0u1440"
    mkfs.msdos -c /dev/fd0u1440 >>$MYLOG 2>&1  && SUCCESS="yes"
    if [ "$SUCCESS" = "" ]; then
      splash end
      DIALOG="$ERRMSG"
      eval $($GTKDIALOG -p DIALOG -c | grep '^\w\w*=')
      [ "$EXIT" = "OK" ] || exit 0
      splash start "$_Formating"
     fi
  done
 fi
  SUCCESS=""
  while [ "$SUCCESS" = "" ]; do
    mount | grep -q '^/dev/fd0[ ]' && umount /dev/fd0 &>/dev/null
    mount | grep -q '/mnt/fd0' && umount /mnt/fd0 &>/dev/null
    mkdir -p /mnt/fd0 &>/dev/null
    mount /dev/fd0 /mnt/fd0 >>$MYLOG 2>&1 && SUCCESS="yes"
    if [ "$SUCCESS" = "" ]; then
      splash end
      DIALOG="$ERRMSG"
      eval $($GTKDIALOG -p DIALOG -c | grep '^\w\w*=')
      [ "$EXIT" = "OK" ] || exit 0
      splash start "$_Formating"
    fi
  done
  splash end
fi

pupopt() {
  PMEDIAOPT=""
  if [ "$PMEDIA" = "" ]; then
    PMEDIA="atahd"
    REMOVABLE="$(cat /sys/block/$DRIVE/removable)"
    if [ "$REMOVABLE" = "1" ]; then
      PMEDIA="usbflash"
    else
      $PROBEDISK | grep "/dev/$DRIVE|" | grep -q -w 'SSD' && PMEDIA="ataflash"
    fi
    PMEDIAOPT="pmedia=$PMEDIA"
  fi
  if [ "$PUPDIR" = "/" ] ;then
    PUPDIR=""
    PSUBDIROPT=""
    SEARCHPATH="$SFSPATH"
  else
    PSUBDIROPT="psubdir=$(echo $PUPDIR| cut -d '/' -f 2)"
    SEARCHPATH="$PUPDIR/$INITRDGZ"
  fi
}
splash start "$_Writing"
SUCCESS=""
if mountpoint $LPART ; then
 TOPDIR=$MP
 TOPPART=$PART
 TOPFS=$FS
 MENU=$TOPDIR/menu.lst
 if [ "$KEEP_MENU" != "true" ] ; then
 FIND_SETROOT="find --set-root --ignore-floppies --ignore-cd"

 for F in $(find $TOPDIR -maxdepth 1 -iname menu.lst)
 do
   STAMP=$(LANG=C stat --format %y $F|cut -d'.' -f 1|tr ' ' '-'|tr -d ':')
   OLDMENU="menu-$STAMP.lst"
   mv -f $F $TOPDIR/$OLDMENU
   SAVEDLST="<text><label>$TOPDIR/$OLDMENU</label></text>"
   ITEM="$PART/$OLDMENU|Previous_menu"
   MENULSTS="$ITEM
$MENULSTS"
 done
 MYITEM="$PART/menu.lst|"
 MENULSTS=$(echo "$MENULSTS" | grep -v "^$MYITEM")

 echo "Writing... $MENU" >>$MYLOG
COLORS="white/blue black/cyan white/black cyan/black"
[ "$TOREMOVABLE" = "1" ] && COLORS="blue/cyan yellow/blue white/black cyan/black"
[ "$(echo $TOPPART|tr -dc '0-9')" != "1" ] && COLORS="white/green yellow/blue white/black green/black"
COLORS="color $COLORS"
SPLASH=$SPLASHPATH
if [ -z "$SPLASH" ]; then
  SPLASH=/splash.xpm.gz
  [ -s "$TOPDIR$SPLASH" ] || SPLASH=/splash.xpm
fi
SPLASH="/$(basename "$SPLASH")"
[ -s "$SPLASHPATH" ] && cp -f "$SPLASHPATH" "$TOPDIR$SPLASH"
SPLASHIMAGE="splashimage=$SPLASH"
[ -s "$TOPDIR$SPLASH" ] && COLORS="#$COLORS" || SPLASHIMAGE="#$SPLASHIMAGE"
	echo "# menu.lst produced by grub4dos-ui-v$MYVERSION
$COLORS
$SPLASHIMAGE
timeout 10
default 0"  >  $MENU 2>>$MYLOG

#frugal entries
TOPPUPPY=""
I=0
if [ "$PUPPIES" != "" ]; then
  echo "
# Frugal installed Puppy"  >>  $MENU
fi
RAMLABEL=""
debug "$PUPPIES"
for ITEM in $PUPPIES
do
  I=$(expr $I + 1)
  eval LABEL=\$\(echo \"\$Frugal_$I\"\|trim\)
  [ "$LABEL" = "" ] && continue
  NEWITEM=$(echo $ITEM|cut -d'|' -f1)
  PART=$(echo $NEWITEM|cut -d '/' -f1)
  SFSPATH=$(echo $NEWITEM | cut -f1 -d',' | sed -e 's,^[^/]*,,')
  SFSBASE=$(basename "$SFSPATH")
  PUPDIR=$(dirname $SFSPATH)
  DRIVE=$(echo $ITEM | cut -d '/' -f 1 | part2drive) 
  KEYFILE=$(echo $NEWITEM | cut -s -f2 -d',')
  INITRDGZ=initrd.gz
  if echo $KEYFILE | grep -q 'initrd'; then
    INITRDGZ=$KEYFILE
  else
    INITRDGZ=$(basename $SFSPATH | grep 'initrd')
  fi
  PMEDIA=""
  PFIX=""
  if [ "$PUPPYOPTIONS" != "" ]; then
    for W in $PUPPYOPTIONS; do
      P=$(echo $W | cut -s -d'=' -f1|tr 'A-Z' 'a-z')
      [ "$P" != "" ] || continue
      V=$(echo $W | cut -d'=' -f2)
      case $P in
        pmedia) PMEDIA=$V;;
        pfix) PFIX=$V;;
      esac
    done
  fi
  PMEDIAOPT=""
  if [ "$PMEDIA" = "" ]; then
    PMEDIAOPT=$(pmediaopt $DRIVE)
  fi
  if [ "$PUPDIR" = "/" ] ;then
    PUPDIR=""
    PSUBDIROPT=""
    SEARCHPATH="$SFSPATH"
  else
    PSUBDIROPT="psubdir=$(echo $PUPDIR| cut -d '/' -f 2)"
    SEARCHPATH="$PUPDIR/$INITRDGZ"
  fi
  HEAD4=$(echo $SFSBASE | cut -b1-4)
  MAJOR=$(echo $SFSBASE | cut -b5| tr -dc '0-9')
  [ "$MAJOR" = "" ] && MAJOR=9
  CLASSICOPT=""
  [ "$HEAD4" = "pup_" -a $MAJOR -lt 3 ] && CLASSICOPT="root=/dev/ram0"
  echo >>  $MENU
  echo "title $LABEL"  >> $MENU
  setroot >>  $MENU
  echo "  kernel $PUPDIR/vmlinuz $CLASSICOPT $PMEDIAOPT $PSUBDIROPT $PUPPYOPTIONS" >> $MENU
  echo "  initrd $PUPDIR/$INITRDGZ" >> $MENU
  if [ "$TOPPUPPY" = "" ]; then
	TOPPUPPY="$LABEL
$(setroot)
  kernel $PUPDIR/vmlinuz $CLASSICOPT $PMEDIAOPT $PSUBDIROPT
  initrd $PUPDIR/$INITRDGZ"   
  fi
 done

#full installed entries
 I=0
if [ "$FULLINSTS" != "" ]; then
  echo "
# Full installed Linux"  >>  $MENU
fi
 for ITEM in $FULLINSTS
 do
  I=$(expr $I + 1)
  eval LABEL=\$\(echo \"\$Full_$I\"\|trim\)
  [ "$LABEL" = "" ] && continue
  NEWITEM=$(echo $ITEM|cut -d'|' -f1)
  PART=$(echo $NEWITEM|cut -d '/' -f1)
  DRIVE=$(echo $PART | part2drive)
  KEYFILE=$(echo $NEWITEM | sed -e 's,^[^/]*,,')
  KEYFILE2=$(echo $KEYFILE| cut -s -d',' -f2)
  KEYFILE1=$(echo $KEYFILE| cut -d',' -f1)
  KDIR=$(dirname $KEYFILE1)
  [ "$KDIR" = "/" ] && KDIR=""
  KBASE=$(basename $KEYFILE1)
  KBASE2=$(basename "$KEYFILE2")
  echo  >>  $MENU
  echo "title $LABEL"  >>  $MENU
  [ "/mnt/$PART" = "$TOPDIR" -a "$KEYFILE1" = "/menu.lst" ] && KEYFILE1=/$OLDMENU
  case "$KBASE" in
  menu.lst)
    if echo $KDIR | grep -q -E 'ubuntu|unetbtin' ; then
      echo "  $FIND_SETROOT $KEYFILE1"  >>  $MENU
    else
     setroot  >>  $MENU
    fi
    echo "  configfile $KEYFILE1"  >>  $MENU
    ;;
  wubildr.mbr)
    if echo $KDIR | grep -q -E 'ubuntu|unetbtin' ; then
      echo "  $FIND_SETROOT $KEYFILE1"  >>  $MENU
    else
     setroot  >>  $MENU
    fi
    echo "  chainloader $KEYFILE1"  >>  $MENU
  ;;
  rootfs*)
     ROOTFSES=$(echo $KEYFILE| sed -e "s|,|\n$KDIR/|g" | sort -r)
     ROOTFSES=$(echo $ROOTFSES)
     setroot   >>  $MENU
      P='null'
      echo "  kernel $KDIR/bzImage root=/dev/$P $LINUXOPTIONS" >>  $MENU
      echo "  initrd $ROOTFSES" >>  $MENU
  ;;
  *.cfg)
	setroot   >>  $MENU
	if [ -f "$APPTMP/$PART$KEYFILE" ]; then
	  KERNEL=$(grep -i 'kernel' "$APPTMP/$PART$KEYFILE"| head -n 1| sed -e 's/^.*kernel //i')
	  INITRD=$(grep -i 'append' "$APPTMP/$PART$KEYFILE"| head -n 1| sed -e 's/^.*initrd=//i')
	  APPEND=$(echo $INITRD| cut -d' ' -f2-)
	  INITRD=$(echo $INITRD| cut -d' ' -f1)
	  echo "  kernel	$KDIR/$KERNEL $APPEND" >>  $MENU
	  echo "  initrd $KDIR/$INITRD" >>  $MENU
	else
		echo "  kernel $KDIR/vmlinuz  changes=/porteus" >>  $MENU
		echo "  initrd $KDIR/initrd.xz" >>  $MENU
	fi
	;;
  *)
    setroot   >>  $MENU
    if [ "$KBASE2" = "" ]; then
      echo "  kernel $KDIR/$KBASE root=/dev/$PART $LINUXOPTIONS" >>  $MENU
    else
      if [[ $LABEL =~ AlphaOS* ]]; then
        BOOTDIR="$(echo $KDIR | sed 's|/boot||g')"
        echo "  kernel $KDIR/$KBASE2 from=$BOOTDIR" >>  $MENU
        echo "  initrd $KDIR/$KBASE" >>  $MENU
      else
        P=$PART
        echo "  kernel $KDIR/$KBASE2 root=/dev/$P $LINUXOPTIONS" >>  $MENU
        echo "  initrd $KDIR/$KBASE" >>  $MENU
      fi
    fi
  ;;
  esac
 done

 echo "
# Windows" >>  $MENU
  eval LABEL=$(echo "$Win_0"|trim)
  debug ":$LABEL:"
 if [ "$LABEL" ] ; then
    echo "# this entry searches Windows on the HDD and boot it up
title $LABEL\nBoot up Windows if installed" >>  $MENU
   [ "$REPLACE" != "" ]  && swapping $FIRSTDRIVE  >>  $MENU
   cat <<EOF  >>  $MENU
  errorcheck off
  $FIND_SETROOT  /bootmgr
  chainloader /bootmgr
  $FIND_SETROOT  /ntldr
  chainloader /ntldr
  $FIND_SETROOT   /io.sys
  chainloader /io.sys
  errorcheck on
EOF
fi

if [ "$ONEPAGE_MENU" != 'true' ]; then
   ADVANCEDMENU=/menu-advanced.lst
   echo "
# Advanced Menu
title Advanced menu
  configfile $ADVANCEDMENU
  commandline" >> $MENU
   MENU=$TOPDIR$ADVANCEDMENU
   echo "# $ADVANCEDMENU  produced by grub4dos-ui-v$MYVERSION" > $MENU
  echo '
title Back to the main menu
  configfile /menu.lst
  commandline' >>  $MENU
fi
  if [ "$TOPPUPPY" ]; then
    LABEL=$(echo "$TOPPUPPY" | head -n1)
    SETROOT=$(echo "$TOPPUPPY" | head -n2 | tail -n1)
    KERNEL=$(echo "$TOPPUPPY" | head -n3 | tail -n1)
    INITRD=$(echo "$TOPPUPPY" | tail -n1)
    # Safe mode
   if [ "$SAFEOPTIONS" ]; then
    echo  >>  $MENU
    echo "title $LABEL Safe mode (without X)\nTry 'xorgwizard' after bootup succeed to start graphic mode."  >>  $MENU
    echo "$SETROOT"  >>  $MENU
    echo "$KERNEL $SAFEOPTIONS"  >>  $MENU
    echo "$INITRD"  >>  $MENU
   fi
    # RAM mode
    echo  >>  $MENU
    echo "title $LABEL RAM mode\nBoot up Puppy without pupsave"  >>  $MENU
    echo "$SETROOT"  >>  $MENU
    echo "$KERNEL pfix=ram"  >>  $MENU
    echo "$INITRD"  >>  $MENU
 fi

if [ $NWIN -gt 1 ]; then
 I=0
 echo "
# Multiple Windows" >>  $MENU
 for ITEM in $WININSTS; do
  I=$(expr $I + 1)
  [ "$ITEM" = 'ALL' ] && I=0
  eval LABEL=\$\(echo \"\$Win_$I\"\|trim\)
  debug ":$LABEL:"
  [ "$LABEL" != "" ] || continue
    echo "
title $LABEL" >>  $MENU
    NEWITEM=$(echo $ITEM|cut -d'|' -f1)
    PART=$(echo $NEWITEM|cut -d '/' -f1)
    KEYFILE=$(echo $NEWITEM | sed -e 's,^[^/]*,,')
   [ "$REPLACE" != "" ]  && swapping $PART  >>  $MENU
   setroot   >>  $MENU
    echo "  chainloader $KEYFILE" >>  $MENU
 done
fi

if [ "$MENULSTS" ]; then
  for ITEM in $MENULSTS; do
    NEWITEM=$(echo $ITEM|cut -d'|' -f1)
    LABEL=$(echo $ITEM| cut -s -f2 -d'|'| tr '_' ' ')"($NEWITEM)"
    PART=$(echo $NEWITEM|cut -d '/' -f1)
    DRIVE=$(echo $PART| part2drive)
    KEYFILE='/'$(echo $NEWITEM | cut -s -f2- -d'/')
    echo  >>  $MENU
    echo "title $LABEL"  >>  $MENU
    setroot   >>  $MENU
    echo "  configfile $KEYFILE
  commandline" >>  $MENU
  done
fi
# boot from PBS
if [ "$CHAINS" != "" ]; then
  echo "
# Boot from Partition Boot Sector"  >>  $MENU
 PBR=":PBS"
 for ITEM in $CHAINS
 do
  make_label; LABEL=$L
  NEWITEM=$(echo $ITEM|cut -d'|' -f1)
  PART=$(echo $NEWITEM|cut -d '/' -f1)
  DRIVE=$(echo $PART| part2drive)
  KEYFILE=$(echo $NEWITEM | sed -e 's,^[^/]*,,')
  KEYFILE2=$(echo $KEYFILE| cut -s -d',' -f2)
  KEYFILE=$(echo $KEYFILE| cut -d',' -f1)
  echo  >>  $MENU
  echo "title $LABEL"  >>  $MENU
  if [ "$REPLACE" != "" ];then
    [ "$DRIVE" != "$TODRIVE" ]  && swapping $DRIVE  >>  $MENU
  elif [ "$DRIVE" != "$FIRSTDRIVE" ]; then
    swapping $DRIVE  >>  $MENU
  fi
  setroot   >>  $MENU
  echo "  chainloader +1" >>  $MENU
 done
 PBR=""
fi
# boot from another drive
N=$(echo "$DRIVES" | wc -l)
if [ $N -gt 1 ]; then
  for DRIVE in $DRIVES; do
    [ "$DRIVE" = "$TODRIVE" ]  && continue
    LABEL=$(echo "$DISKS" | grep -w $DRIVE | cut -f3 -d'|' | tr '_' ' ')
    LABEL="Boot from $DRIVE ($LABEL)"
    echo  >>  $MENU
    echo "title $LABEL"  >>  $MENU
    if [ "$REPLACE" != "" ];then
      [ "$DRIVE" != "$TODRIVE" ]  && swapping $DRIVE  >>  $MENU
    elif [ "$DRIVE" != "$FIRSTDRIVE" ]; then
      swapping $DRIVE  >>  $MENU
    fi
    echo "  chainloader (hd0)+1"  >>  $MENU
  done
fi
# PLOP boot manager
if [ "$BOOTMGRS" != "" ]; then
  echo "
# Chain to other boot managers"  >>  $MENU
 for ITEM in $BOOTMGRS
 do
  make_label; LABEL=$L
  NEWITEM=$(echo $ITEM|cut -d'|' -f1)
  PART=$(echo $NEWITEM|cut -d '/' -f1)
  DRIVE=$(echo $PART| part2drive) #v1.7.2
  KEYFILE=$(echo $NEWITEM | sed -e 's,^[^/]*,,')
  KEYFILE2=$(echo $KEYFILE| cut -s -d',' -f2)	# can be vmlinuz
  KEYFILE=$(echo $KEYFILE| cut -d',' -f1)
  echo  >>  $MENU
  echo "title $LABEL"  >>  $MENU
  setroot  >>  $MENU
  echo "  kernel $KEYFILE"  >>  $MENU
 done
fi
# tail
echo >>  $MENU
echo "# additionals" >>  $MENU
if [ "$MBR" = "" -a "$PLOCAL" = "" ]; then
  echo "title Bootup from HDD\nBootup from the master boot record of the hard disk drive"  >>  $MENU
  [ "$REPLACE" != "" ]  && swapping $FIRSTDRIVE  >>  $MENU
  echo "  chainloader (hd$X)+1"  >>  $MENU
fi
if [ "$TOREMOVABLE" = "1" -a "$PLOCAL" = "" ]; then
  if [ "$LEGACY_MENU" != "true" ]; then
    echo >>  $MENU
    echo "title Find Grub menu on HDD"  >>  $MENU
    [ "$REPLACE" != "" ]  && swapping $FIRSTDRIVE  >>  $MENU
    cat <<EOF  >>  $MENU
  errorcheck off
  $FIND_SETROOT /menu.lst && configfile /menu.lst
  $FIND_SETROOT /boot/grub/menu.lst && configfile /boot/grub/menu.lst
  $FIND_SETROOT /grub/menu.lst && configfile /grub/menu.lst
  errorcheck on
  commandline
EOF
   fi
 fi

 if [ "$LEGACY_MENU" != "true" -a "$PLOCAL" = "" ]; then
   cat <<EOF  >>  $MENU

title Find Grub2\nBoot up grub2 if installed
  $FIND_SETROOT /boot/grub/core.img
  kernel /boot/grub/core.img
EOF
  fi
  cat <<EOF  >>  $MENU

title Grub4Dos commandline\n(for experts only)
  commandline

title Reboot computer
  reboot

title Halt computer
  halt
EOF
    sync
    [ -s "$MENU" ] && SUCCESS="yes" || SUCCESS=""
    [ "$SUCCESS" = "yes" ] || echo "Failed to make 'menu.lst'." >>$MYLOG
 else ### skip menu end
   SUCCESS="yes"
 fi
# install grldr  #v1.8: moved up
if [ "$SUCCESS" = "yes" ]; then
  echo "Installing $GRUBLOADER ..." >>$MYLOG
  cp -v -f  /usr/lib/grub4dos/$GRUBLOADER  $TOPDIR >>$MYLOG 2>&1 || SUCCESS=""
  sync || SUCCSESS=""
  [ -s $TOPDIR/$GRUBLOADER ] || SUCCESS=""
  [ "$SUCCESS" = "" ] && echo "Failed to install '$GRUBLOADER'." >>$MYLOG
fi

if [ "$KEEP_BOOT_RECORD" != "true" -a  "$SUCCESS" = "yes" ]; then
# install boot sector
SUCCESS=""
MBROPT=""
[ "$BINSTALLER" = "bootlace.com" ] && MBROPT="--boot-prevmbr-last --time-out=0"
if [ "$BOOTLOADER" != "" ]; then
    # check boot flag and mbr # 7feb11 fix typo
 if [ "$FLOPPY" = "" ]; then
    is_bootable /dev/$TODRIVE && BOOTABLEMBR="yes" || BOOTABLEMBR=""
    [ "$(boot_part /dev/$TODRIVE)" = "$TOPPART" ] && BOOTABLEPBS="yes" || BOOTABLEPBS=""
    debug "/dev/$TODRIVE Bootalbe: $BOOTABLEMBR, $BOOTABLEPBS"
 fi
 SUCCESS=""
  if [ "$FLOPPY" != "" ];then
    mount | grep -q '^/dev/fd0[ ]' && umount /dev/fd0 &>/dev/null
    OPT="--floppy --chs"
    echo "Installing bootloader on floppy..." >>$MYLOG
    debug "$BINSTALLER $OPT /dev/fd0"
    $BINSTALLER $OPT /dev/fd0 >>$MYLOG 2>&1 && SUCCESS="yes"
  elif [ "$PBSINSTALL" != "" ]; then
    EXTFS=""
    X=0; Y=0
    partname2num $WHERETO
    OPT="-v -p=$Y"
    TARGET=/dev/$TODRIVE
   if [ "$BINSTALLER" = "bootlace.com" ]; then
    case $TOPFS in
    ntfs) OPT="--ntfs"
	;;
    vfat) OPT=""
	;;
	ext4) BINSTALLER="extlinux"

	  cp -vf "$CHAINLOADER" $TOPDIR >>$MYLOG 2>&1 && SUCCESS="yes"
	  if [ "$SUCCESS" = "yes" ]; then
      # save backup
      F="$TOPDIR/extlinux.conf"
      if [ -s "$F" ]; then
        STAMP=$(LANG=C stat --format %y "$F"|cut -d'.' -f 1|tr ' ' '-'|tr -d ':')
        OLDMENU="extlinux.-$STAMP.conf"
        mv -f "$F" "$TOPDIR/$OLDMENU"
        SAVEDLST="$SAVELIST<text><label>$TOPDIR/$OLDMENU</label></text>"
      fi
	   echo "Writing $TOPDIR/extlinux.conf..." >>$MYLOG
	   echo "default chain.c32 ntldr=grldr" > $TOPDIR/extlinux.conf || SUCCESS=""
      fi
      if [ "$SUCCESS" = "yes" ]; then
        echo "Installing $BINSTALLER on /dev/$PART(PBS)..." >>$MYLOG
        debug "extlinux --install $TOPDIR"
        extlinux --install $TOPDIR >>$MYLOG 2>&1 || SUCCESS=""
      fi
	;;
    *)
     PTABLE=$(LANG=C fdisk -u -l "/dev/$DRIVE")
     N=0
     for COL in $(echo "$PTABLE"| grep 'heads')
     do
      if echo "$COL" | grep -q 'heads'
      then H=$N
      elif echo "$COL" | grep -q 'sectors/track'
      then S=$N
      fi
	  N=$COL
     done
     ALINE=$(echo "$PTABLE"| grep -w "^/dev/$PART"|tr -d '*'| tr -s ' ')
     debug "$ALINE"
     B=$(echo $ALINE|cut -d' ' -f2)
     T=$(echo $ALINE|cut -d' ' -f4)
     OPT="--sectors-per-track=$S --heads=$H --start-sector=$B --total-sectors=$T"
       [ "$S" = "" ] && OPT="error"
     TARGET=/dev/$TOPART
	;;
    esac
    OPT="--floppy=$Y $OPT"
    TARGET=/dev/$PART
   fi
   if [ "$BINSTALLER" != "extlinux" ]; then
     echo "Installing bootloader on /dev/$PART(PBS)..." >>$MYLOG
     $BINSTALLER $OPT $TARGET >>$MYLOG 2>&1  && SUCCESS="yes" || SUCCESS=""
   fi
 else
   if [ "$BOOTLOADER" = "wee" ]; then
     cp -f /usr/lib/grub4dos/wee.mbr /tmp/wee.mbr >>$MYLOG 2>&1
     dd if=/dev/$WHERETO bs=1 skip=439 count=72 2>/dev/null | \
	 dd of=/tmp/wee.mbr bs=1 seek=439 conv=notrunc >>$MYLOG 2>&1
     MD5SUMNEW=$(md5sum /tmp/wee.mbr | cut -d' ' -f1)
     # backup MBR
     MBRBAK=""
     dd if=/dev/$WHERETO of=/tmp/$WHERETO.mbr bs=512 count=63 >>$MYLOG 2>&1
     MD5SUMOLD=$(md5sum /tmp/$WHERETO.mbr | cut -d' ' -f1)
     # Write wee MBR to $MBR_DEV
     echo "Installing bootloader(Wee) on /dev/$WHERETO ..." >>$MYLOG
     dd if=/tmp/wee.mbr of=/dev/$WHERETO >>$MYLOG 2>&1  && SUCCESS="yes" || SUCCESS=""
   else
     # backup MBR
     MBRBAK=""
     dd if=/dev/$WHERETO of=/tmp/$WHERETO.mbr bs=512 count=1 >>$MYLOG 2>&1
     # Write grub4dos MBR
     echo "Installing bootloader on /dev/$WHERETO ..." >>$MYLOG
     $BINSTALLER $MBROPT /dev/$WHERETO  >>$MYLOG 2>&1  && SUCCESS="yes"
     dd if=/dev/$WHERETO of=/tmp/$WHERETO.mbrnew bs=512 count=1 >>$MYLOG 2>&1
     MD5SUMOLD=$(md5sum /tmp/$WHERETO.mbr | cut -d' ' -f1)
     MD5SUMNEW=$(md5sum /tmp/$WHERETO.mbrnew | cut -d' ' -f1) 
     rm -f /tmp/$WHERETO.mbrnew
   fi
   if [ "$MD5SUMNEW" != "$MD5SUMOLD" ]; then
      echo "Making backup of the MBR(/dev/${WHERETO}) ..." >>$MYLOG
      cp -vf /tmp/$WHERETO.mbr $TOPDIR/${WHERETO}_mbr.bak >>$MYLOG 2>&1 && MBRBAK="$TOPDIR/${WHERETO}_mbr.bak"
   fi
  fi
  [ "$SUCCESS" = "" ] && echo "Failed to install $BINSTALLER." >>$MYLOG
 fi
fi
fi	# long skip if error occured
splash end
# finish
if [ "$SUCCESS" = "" ]; then
 DIALOG="<window title=\"$_Title - Error\" icon-name=\"grub4dos-ui\"><vbox>
   <pixmap icon_size=\"5\">
    <input file stock=\"gtk-dialog-error\"></input>
   </pixmap>
 <frame>
 <text><label>$_Error</label></text>
 <button><label>See $MYLOG</label>
   <action>\$EDITOR $MYLOG &</action></button>
  </frame>
  <text><label>$_Quit</label></text>
  <hbox>
   <button ok></button>
  </hbox>
  </vbox></window>"
 $GTKDIALOG -p DIALOG -c &>/dev/null
 exit 1
fi
# success
WARNMARK="     <pixmap icon_size=\"5\">
       <input file stock=\"gtk-dialog-warning\"></input>
     </pixmap>"

FILES="'grldr'"
[ "$KEEP_MENU" != "true" ] && FILES="$FILES, 'menu.lst'"
 MORE=""
[ "$SAVEDLST" != "" ] && MORE="<text><label>$_Saved</label></text>$SAVEDLST"
if [ "$KEEP_BOOT_RECORD" = "true" ]; then
  MBR=""
  MORE="$MORE
  <text><label>$_NoBR</label></text>"
elif [ "$MBRBAK" != "" ]; then
  MORE="$MORE
<text><input>echo -en \"$_MBR_saved: $MBRBAK\n$_Restore_MBR:\"</input></text>
<text selectable=\"true\"><input>echo -en \"cat $MBRBAK > /dev/$WHERETO\"</input></text>"
fi
 [ "$BOOTLOADER" != "" ] || MBR=""
 if [ "$MBR" = "" -a "$FLOPPY" = ""  ] ; then
   MORE="$MORE
   <text><label>$_NoMBR: $WHERETO</label></text>"
 fi
 if [ "$MBR" = "" -a "$FLOPPY" = "" -a "$BOOTABLEMBR" = "" ]; then
    MORE="$MORE
    $WARNMARK
   <text><label>$(printf "$_NoBootMBR" /dev/$TODRIVE)</label></text>"
   WARNMARK=""
 fi
 if [ "$PBSINSTALL" != "" -a "$BOOTABLEPBS" = "" ]; then
   MORE="$MORE
   $WARNMARK
   <text><label>$(printf "$_NoBootFlag" /dev/$TOPPART)</label></text>"
 fi
 [ "$FLOPPY" = "" ] && TOREMOVABLE=$(cat /sys/block/$TODRIVE/removable) || TOREMOVABLE="1"
 if [ "$TOREMOVABLE" != "0" ]; then
    MORE="$MORE
   <text><label>$_Unmount</label></text>"
fi
 [ "$FLOPPY" != "" ] &&  mount /dev/fd0 /mnt/fd0
 EDITADVANCED="<button><input file icon=\"document-properties\"></input>
 <label>\"$_Edit_Advanced\"</label><action>\$EDITOR $TOPDIR$ADVANCEDMENU &</action></button>"
 [ "$ONEPAGE_MENU" = 'true' ] && EDITADVANCED=""
 DIALOG="<window title=\"$_Title - Success\" resizable=\"false\" icon-name=\"grub4dos-ui\"><vbox>
 <frame>
  <text use-markup=\"true\"><label>\"$_Success $_Fairwell1 $FILES $_Fairwell2 <b>$TOPDIR</b>. $_Fairwell3\"</label></text>
  $MORE
  <hbox>
    <button><input file icon=\"document-properties\"></input>
    <label>\"$_Edit\"</label><action>\$EDITOR $TOPDIR/menu.lst &</action></button>
    $EDITADVANCED
    <button><input file icon=\"zoom-fit\"></input><label>$(echo 'See log')</label>
   <action>\$EDITOR $MYLOG &</action></button>
   </hbox>
  <hbox>
  <button><input file stock=\"gtk-info\"></input><label>$_More_info</label><action>$BROWSER $_WebPage &</action></button>
  </hbox>
 </frame>
  <text><label>$_Quit</label></text>
  <hbox>
   <button ok></button>
  </hbox>
  </vbox></window>"  
 $GTKDIALOG -p DIALOG -c &>/dev/null
 rm -f $MYLOG
 exit 0
